## Get rid of AsIs class attribute for making sort work
unAsIs <- function(X) {
    if(inherits(X, "AsIs")) {
        class(X) <- class(X)[-match("AsIs", class(X))]
    }
    X
}

## Class Constructor
NPRData <- function(d, cutoff, class) {
    Xindex <- if (class=="FRD") 3 else 2
    ## Unclass in case generated by I()
    if(is.unsorted(d[[Xindex]]))
        d <- d[sort(unAsIs(d[[Xindex]]), index.return=TRUE)$ix, ]
    Y <- if (class=="FRD") cbind(d[[1]], d[[2]]) else d[[1]]

    df <- list(Y=Y, X=d[[Xindex]] - cutoff, orig.cutoff=cutoff,
               class=class, var.names=names(d)[1:Xindex])
    df$p <- df$X>=0
    df$m <- df$X<0
    df$sigma2 <- d$"(sigma2)"
    df$clusterid <- d$"(clusterid)"
    df$w <- if(is.null(d$"(weights)")) rep(1L, length(df$X)) else d$"(weights)"
    df
}



## Find interval containing zero of a function, then find the zero
## Search an interval for a root of \code{f},
## @param f function whose root we're looking for
## @param ival upper endpoint of initial interval in which to search
## @param negative logical: should the lower endpoint be \code{1/ival} (if the
##     root is guaranteed to be positive), or \code{-ival}?
FindZero <- function(f, ival=1.1, negative=TRUE) {
    minval <- function(ival) if (negative==TRUE) -ival else min(1/ival, 1e-3)

    while(sign(f(ival))==sign(f(minval(ival))))
            ival <- 2*ival
    stats::uniroot(f, c(minval(ival), ival), tol=.Machine$double.eps^0.75)$root
}


## Modified golden section for unimodal piecewise constant function
gss <- function(f, xs) {
    gr <- (sqrt(5) + 1) / 2
    a <- 1
    b <- length(xs)
    c <- round(b - (b - a) / gr)
    d <- round(a + (b - a) / gr)

    while (b - a > 100) {
        if (f(xs[c]) < f(xs[d])) {
            b <- d
        } else {
            a <- c
        }

        # recompute both c and d
        c <- round(b - (b - a) / gr)
        d <- round(a + (b - a) / gr)
    }

    supp <- xs[a:b]
    supp[which.min(vapply(supp, f, numeric(1)))]
}
