## Get rid of AsIs class attribute when X is generated by I() for making sort
## work
unAsIs <- function(X) {
    if (inherits(X, "AsIs")) {
        class(X) <- class(X)[-match("AsIs", class(X))]
    }
    X
}

## Class Constructor
NPRData <- function(d, cutoff, class) {
    Xidx <- if (class=="FRD") 3 else 2
    if (is.unsorted(d[[Xidx]]))
        d <- d[sort(unAsIs(d[[Xidx]]), index.return=TRUE)$ix, ]
    Y <- as.matrix(d)[, seq_len(Xidx-1)]
    X <- d[[Xidx]] - cutoff
    covs <- stats::model.matrix(attr(d, "terms"), d)[, -seq_len(Xidx)]

## mt <- attr(mfff, "terms")
##  y <- model.response(mfff, "numeric")
##  w <- as.vector(model.weights(mfff))

    df <- structure(list(Y=Y, X=X, orig.cutoff=cutoff, covs=covs, p=X>=0, m=X<0,
                         var.names=c(names(d)[seq_len(Xidx)], colnames(covs)),
                         clusterid=d$"(clusterid)"),
                    class=class)
    if (class!="FRD") {
        df$sigma2 <- d$"(sigmaY2)"
    } else if (!is.null(d$"(sigmaY2)")) {
        df$sigma2 <- cbind(d$"(sigmaY2)", d$"(sigmaYD)", d$"(sigmaYD)",
                           d$"(sigmaD2)")
    }
    df$w <- if (is.null(d$"(weights)")) rep(1L, length(X)) else d$"(weights)"
    df
}



## Find interval containing zero of a function, then find the zero
## Search an interval for a root of \code{f},
## @param f function whose root we're looking for
## @param ival upper endpoint of initial interval in which to search
## @param negative logical: should the lower endpoint be \code{1/ival} (if the
##     root is guaranteed to be positive), or \code{-ival}?
FindZero <- function(f, ival=1.1, negative=TRUE) {
    minval <- function(ival) if (negative==TRUE) -ival else min(1/ival, 1e-3)

    while (sign(f(ival))==sign(f(minval(ival))))
        ival <- 2*ival
    stats::uniroot(f, c(minval(ival), ival), tol=.Machine$double.eps^0.75)$root
}


## Modified golden section for unimodal piecewise constant function
gss <- function(f, xs) {
    gr <- (sqrt(5) + 1) / 2
    a <- 1
    b <- length(xs)
    c <- round(b - (b - a) / gr)
    d <- round(a + (b - a) / gr)

    while (b - a > 100) {
        if (f(xs[c]) < f(xs[d])) {
            b <- d
        } else {
            a <- c
        }

        # recompute both c and d
        c <- round(b - (b - a) / gr)
        d <- round(a + (b - a) / gr)
    }

    supp <- xs[a:b]
    supp[which.min(vapply(supp, f, numeric(1)))]
}
