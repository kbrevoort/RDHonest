## Get rid of AsIs class attribute for making sort work
unAsIs <- function(X) {
    if (inherits(X, "AsIs")) {
        class(X) <- class(X)[-match("AsIs", class(X))]
    }
    X
}

## Class Constructor
NPRData <- function(d, cutoff, class) {
    Xidx <- if (class=="FRD") 3 else 2
    ## Unclass in case generated by I()
    if (is.unsorted(d[[Xidx]]))
        d <- d[sort(unAsIs(d[[Xidx]]), index.return=TRUE)$ix, ]
    Y <- drop(as.matrix(d[, seq_len(Xidx-1)]))
    W <- stats::model.matrix(attr(d, "terms"), d)[, -seq_len(Xidx)]

    df <- structure(list(Y=Y, X=d[[Xidx]] - cutoff, orig.cutoff=cutoff, W=W,
                         var.names=c(names(d)[1:Xidx], colnames(W))),
                    class=class)
    df$p <- df$X>=0
    df$m <- df$X<0
    if (class!="FRD") {
        df$sigma2 <- d$"(sigmaY2)"
    } else if (!is.null(d$"(sigmaY2)")) {
        df$sigma2 <- cbind(d$"(sigmaY2)", d$"(sigmaYD)", d$"(sigmaYD)",
                           d$"(sigmaD2)")
    }

    df$clusterid <- d$"(clusterid)"
    df$w <- if (is.null(d$"(weights)")) rep(1L, length(df$X)) else d$"(weights)"
    df
}



## Find interval containing zero of a function, then find the zero
## Search an interval for a root of \code{f},
## @param f function whose root we're looking for
## @param ival upper endpoint of initial interval in which to search
## @param negative logical: should the lower endpoint be \code{1/ival} (if the
##     root is guaranteed to be positive), or \code{-ival}?
FindZero <- function(f, ival=1.1, negative=TRUE) {
    minval <- function(ival) if (negative==TRUE) -ival else min(1/ival, 1e-3)

    while (sign(f(ival))==sign(f(minval(ival))))
        ival <- 2*ival
    stats::uniroot(f, c(minval(ival), ival), tol=.Machine$double.eps^0.75)$root
}


## Modified golden section for unimodal piecewise constant function
gss <- function(f, xs) {
    gr <- (sqrt(5) + 1) / 2
    a <- 1
    b <- length(xs)
    c <- round(b - (b - a) / gr)
    d <- round(a + (b - a) / gr)

    while (b - a > 100) {
        if (f(xs[c]) < f(xs[d])) {
            b <- d
        } else {
            a <- c
        }

        # recompute both c and d
        c <- round(b - (b - a) / gr)
        d <- round(a + (b - a) / gr)
    }

    supp <- xs[a:b]
    supp[which.min(vapply(supp, f, numeric(1)))]
}
